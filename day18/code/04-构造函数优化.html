<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        function Factory(name, water){
            this.name = name
            this.water = water
        }
        //使用原型对象
        Factory.prototype.juicing = function(){
            console.log(this.name + '汁')
        }
        Factory.prototype.num = 10
        
        //实例化对象
        let peach = new Factory('桃子', 5)
        let apple = new Factory('苹果', 2)
        
        peach.juicing()
        apple.juicing()

        //注意点：每创建一个实例化对象，都会在内存里面开辟一块空间，对于函数来说指向是不一样的，所以它们不相等
        //console.log(peach.juicing == apple.juicing) //false

        /*
            prototype
            + 为了解决构造函数实例化出来的不同对象调用方法内存地址不相等的问题，构造函数给咱们提供了一个属性帮助咱们解决问题，这个属性
            叫做prototype
            + 这个属性指向一个对象，这个对象里面可以保存咱们的方法，并且只要是这个对象里面的方法都可以实现共享（内存地址一致）
            + 把prototype属性指向的这个对象称之为原型对象
        */
        console.log(peach.juicing == apple.juicing) //true

        //原型对象
        console.log(Factory.prototype)
        console.log(Array.prototype)
        console.log(Date.prototype)

    </script>
</body>
</html>